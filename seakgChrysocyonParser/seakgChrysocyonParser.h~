#ifndef __SEAKGCHRYSOCYONPARSER_H__
#define __SEAKGCHRYSOCYONPARSER_H__

#include <vector>
#include <iostream>

namespace seakgChrysocyon
{
	//-----------------------------------------------
	// ENUM ANSWER TYPE

	enum chrysocyonAnswer
	{
		schsNone = 0, // точно нет или я отказываюсь
		schsYetUnknown = 1, //еще не знаю или еще не определился давай дальше
		schsMaybe = 2, // Может быть мое
		schsOnlyMe = 3, // Точно мое ( и должно быть только мое )
		schsComplete = 4, // да я закончил можешь забирать результат
	};
	//-----------------------------------------------
	// READER
	
	template<typename Element>
	class InterfaceChrysocyonReader // interface
	{
		public:
			virtual bool Eof() = 0;
			virtual bool GetNextElement( Element &, int & ) = 0;
	};
	
	//-----------------------------------------------
	// PUPPY
	
	template<typename Element, typename ArrayOfElement>
	class InterfaceChrysocyonPuppy // interface
	{
		public:
			virtual chrysocyonAnswer SendElement(Element) = 0;
			virtual ArrayOfElement &GetResult() = 0;
			virtual void Reset() = 0;
			virtual bool StepBack() = 0;
	};
	
	//-----------------------------------------------
	// PARSER

	enum chrysocyonErrors
	{
		chsErrEof = -1, // неожиданные конец файла
		chsErrUnknownAnswer = -2, // неизвестный ответ
		chsErrNotFoundPuppy = -3, // ненайден щенок
		chsErrTooManyPuppiesSayOnlyMe = -4, // более одного щенка заявили на права
		chsErrTooManyPuppiesSayCompleted = -5, // более одного щенка заявили что закончили
		chsErrUnknown = -6 // более одного щенка заявили что закончили
	};

	
	template<typename Element, typename ArrayOfElement>
	class chrysocyonParser : public InterfaceChrysocyonReader<ArrayOfElement> // parser
	{
		typedef InterfaceChrysocyonReader<Element> Reader;
		typedef InterfaceChrysocyonPuppy<Element, ArrayOfElement> Puppy;
		typedef std::vector<InterfaceChrysocyonPuppy<Element, ArrayOfElement> *> ArrayOfPuppy;
		
		//typedef seakgChrysocyonContainer<Element> Container;
		
		public: 
			chrysocyonParser(Reader *reader) : m_pReader(reader), m_bStepBack(false) { };
			void AddPuppy(Puppy* puppy) { m_vectorPuppies.push_back(puppy); };

			// InterfaceChrysocyonReader
			virtual bool Eof()
			{
			  return m_pReader->Eof();	
			};

			virtual bool GetNextElement( ArrayOfElement &result,  int& nOutErrorCode = 0 )
			{
//				std::cout << "start\n";
				ArrayOfPuppy tempPuppy, bufPuppy;
				tempPuppy.clear();
				CopyArrayOfPuppy( m_vectorPuppies, tempPuppy);
				
				Puppy *puppyOnlyMe;
				Puppy *puppyComplete;
				int nPuppyOnlyMe;
				int nPuppyComplete;
				int nBufPuppy;

//				std::cout << "before while\n";
				if( m_bStepBack )


				while( !m_pReader->Eof() )
				{
					//std::cout << "into while\n";

					int nErrorCode = 0;
					Element elem;

					nPuppyOnlyMe = 0;
					nPuppyComplete = 0;
					nBufPuppy = 0;
					bufPuppy.clear();

					// get next element
					if( m_pReader->GetNextElement(elem, nErrorCode ) )
					{
						m_elementStore = elem;

						for(int i = 0; i < tempPuppy.size(); i++)
						{
							seakgChrysocyon::chrysocyonAnswer answer = tempPuppy[i]->SendElement(elem);
							//std::cout << (int)answer << "\n";
							if( answer == schsNone )
							{
								//nothing
							}
							else if( answer == schsYetUnknown || answer == schsMaybe )
							{
								bufPuppy.push_back(tempPuppy[i]);
								nBufPuppy++;
							} 
							else if( answer == schsOnlyMe )
							{
								puppyOnlyMe = tempPuppy[i];
								nPuppyOnlyMe++;
							}						
							else if( answer == schsComplete )
							{
								puppyComplete = tempPuppy[i];
								nPuppyComplete++;
							}
							else
							{
								nOutErrorCode = chsErrUnknownAnswer;
								return false;
							};
						};
						
						if( nPuppyOnlyMe == 0 && nPuppyComplete == 1 && nBufPuppy == 0)
						{
							//std::cout << " complete \n";
							result = puppyComplete->GetResult();
							ResetAllPuppy();
							bufPuppy.clear();
							tempPuppy.clear();
							nOutErrorCode = 0;
							return true;
						}
						else if( nPuppyOnlyMe == 1 && nPuppyComplete == 0 && nBufPuppy == 0)
						{
							//std::cout << " onlyme \n";
							bufPuppy.clear();
							bufPuppy.push_back( puppyOnlyMe );
						}
						else if( nPuppyOnlyMe == 0 && nPuppyComplete == 0 && nBufPuppy  > 0 )
						{
							//std::cout << " next step \n";
							tempPuppy.clear();
							CopyArrayOfPuppy( bufPuppy, tempPuppy );
							bufPuppy.clear();
							// goto next step
						}
						else if( nPuppyOnlyMe == 0 && nPuppyComplete == 0 && nBufPuppy == 0 )
						{
							//std::cout << " not found puppy \n";
							nOutErrorCode = chsErrNotFoundPuppy;
							return false;
						}
						else if( nPuppyOnlyMe > 1 && nPuppyComplete == 0 && nBufPuppy == 0 )
						{
							//std::cout << " too many only me \n";
							nOutErrorCode = chsErrTooManyPuppiesSayOnlyMe;
							return false;
						}
						else if( nPuppyOnlyMe == 0 && nPuppyComplete > 1 && nBufPuppy == 0 )
						{
							std::cout << " too many completed \n";
							nOutErrorCode = chsErrTooManyPuppiesSayCompleted;
							return false;
						}
						else
						{
							//error Unknown
							nOutErrorCode = chsErrUnknown;
							return false;
						};
					}
					else
					{
						// error : return error code
						nOutErrorCode = nErrorCode;
						return false;
					};

				};
	
//				std::cout << "after while\n";

				if( m_pReader->Eof() )
				{
					nOutErrorCode = chsErrEof;
					return false;
				};
				
				return true;
			};
			
		private:			

			Reader * m_pReader;
			ArrayOfPuppy m_vectorPuppies;

			void CopyArrayOfPuppy(const ArrayOfPuppy &src, ArrayOfPuppy &dst)
			{
				for(int i = 0; i < src.size(); i++)
					dst.push_back(src[i]);
				return;
			};			
			void ResetAllPuppy()
			{
				for(int i = 0; i < m_vectorPuppies.size(); i++)
					m_vectorPuppies[i]->Reset();
			};
			bool m_bStepBack;
			Element m_elementStore;
	};
	
	//-----------------------------------------------
};

#endif // __SEAKGCHRYSOCYONPARSER_H__
